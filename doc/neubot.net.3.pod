=head1 NAME

neubot.net - Neubot's asynchronous I/O module

=head1 SYNOPSYS

B<import neubot>

B<neubot.net.connect>(address, port, connected, connecting=None,
    cantconnect=None, poller=neubot.net.pollers.poller,
    family=socket.AF_INET, secure=False, conntimeo=10)

B<neubot.net.listen>(address, port, accepted, listening=None,
    cantbind=None, poller=neubot.net.pollers.poller,
    family=socket.AF_INET, secure=False, certfile=None,
    maxclients=7, maxconns=4)

stream.I<recv>(maxlen, recv_success, recv_error=None)

stream.I<send>(octets, send_success, send_error=None)

stream.I<close>()

stream.I<timeout> = timeout

stream.I<notify_closing> = closing

eof = stream.I<eof>

stream.I<context> = context

B<neubot.net.loop>()

=head1 DESCRIPTION

This manual page presents Neubot's asynchronous I/O module.  The general
idea is that you start an I/O operation and register a callback to be
invoked when such operation completes successfully, and, optionally,
a callback to be invoked in case of failure, and, possibly, many more
callbacks.  The I/O module machinery will then perform the operation
on your behalf, and, depending on the result, will invoke the proper
callback.

The function B<neubot.net.connect>() starts an asynchronous connect(2)
to the specified I<address> and I<port>.  In case of success the function
I<connected> is invoked, while I<cantconnect>, if specified, is invoked
in case of failure.  The optional function I<connecting> is invoked when
we are waiting for the connection to complete, and might be useful to
print a message such as "Connection in progress...".  If <secure> is True,
and the connection completes successfully, the I/O module will also wrap
the connected socket with an ssl(3) object.  The I<conntimeo> parameter
specifies the maximum amount of seconds we can wait for the connection
to complete.  The I<poller> parameter serves to specify an alternate
B<Poller> object (which is the core class of the I/O module and dispatches
I/O events)--usually you don't need to do that.  The I<family> parameter
allows one to override the default protocol family, that is IPv4.

The function B<neubot.net.listen>() creates a stream socket listening to
the specified I<address> and I<port> and waits for incoming connections.
If it is not possible to listen to the specified address and port,
the I/O module invokes the function I<cantbind>, otherwise it invokes
the function I<listening>, which might be useful to print a message
such as "Listening on port 80."  When there is an incoming connection,
the function I<accepted> is invoked.  The I<certfile> parameter might
be used to specify the path of the certificate file.  The I/O module
does not accept connections from more than I<maxclients> clients and
allows each client to open up to I<maxconns> connections.  All the
other parameters have the same meaning of the corresponding ones of
B<neubot.net.connect>().

The I<connected> and I<accepted> callbacks receive a parameter that is
conventionally named I<stream> and is an instance of the B<Stream> class.
This class wraps either a socket or an SSL object and implements three
asynchronous I/O operations: recv(), send(), and close().

The recv() method starts an asynchronous recv operation.  The operation
will read up to I<maxlen> bytes and the I/O module machinery will
invoke I<recv_success> on success, and I<recv_error> on failure.
The first function receives two parameters: a reference to the stream
and a reference to a string that contains the read bytes.  The second one
receives a reference to the stream as its only parameter.

The send() method starts an asynchronous send operation.  The operation
will send the I<octets> string over the network and the I/O module
machinery will invoke I<send_success> on success, and I<send_error>
on failure.  The first function receives two parameters: a reference
to the stream and a reference to the sent string.  The second one
receives a reference to the stream as its only parameter.

The close() method close the underlying socket or SSL connection and
frees all the resources.  It is important that you drop any reference
to the stream object after the close, for the object to be correctly
garbage collected.  An alternative to an explicit close is to drop
the references to the stream either in the recv_success() or in the
send_success() callback (this works because the I/O module does not keep
any reference to the stream when these callbacks are running.)

Apart from these three methods, there are some worth mentioning members
of the B<Stream> class: I<timeout>, I<notify_closing>, I<eof>, and
I<context>.

The I<timeout> member specifies the timeout (in seconds) for recv and
send I/O operations.

If the I<notify_closing> callback is not None, it will be invoked when
the stream is closing.  This is an alternate mechanism to get notified
that a pending I/O operation failed, and could be employed instead of
I<recv_error> and I<send_error>.

The I<eof> member is True when the remote host closed the connection.
It allows to discriminate between a legitimate close from the remote
host and another network error.  This might be useful if the protocol
specifies that certain messages are EOF terminated (as happens, for
example, with HTTP/1.0).

The I<context> member is the proper place where to store a reference
to the context attached to a network connection (such as the state of
the HTTP protocol.)  Indeed, if this member is the only reference to
the context, the stream distruction will also trigger the distruction
of the context object (removing the need of an explicit notification.)

The function B<neubot.net.loop>() keeps running the module machinery
and dispatches I/O events to the interested streams.  If you forget to
invoke this function your program will not perform any network I/O.

=head1 EXAMPLES

In this example we retrieve the raw response of a remote webserver.
We don't do any error checking for simplicity:

    import neubot
    import sys

    class Getraw:
        def __init__(self, host):
            self.request  = "GET / HTTP/1.1\r\n"
            self.request += "Host: " + host + "\r\n"
            self.request += "Connection: close\r\n"
            self.request += "\r\n"
            neubot.net.connect(host, "80", self.connected)

        def connected(self, stream):
            stream.send(self.request, self.sent)

        def sent(self, stream, octets):
            stream.recv(8000, self.received)

        def received(self, stream, octets):
            sys.stdout.write(octets)
            stream.recv(8000, self.received)

    if __name__ == "__main__":
        Getraw(sys.argv[1])
        neubot.net.loop()

In __init__() we prepare the request, we start an asynchronous connect,
and we register self.connected to be invoked once the connection is
complete.

When the connection completes, self.connected() starts an asynchronous
send, and registers self.sent to be invoked once the request has been
sent.

When the request has been sent, self.sent() starts an asynchronous recv,
and registers self.received to be invoked once some bytes are received.

The function self.received() prints on the standard output the chunk
received and then starts another asynchronous receive operation.
This repeats until the server closes the connection.

In the main we construct the Getraw object and we invoke the main loop
of the I/O module, neubot.net.loop().

Assuming the example above is contained in the file getraw.py and assuming
that Neubot is installed in /usr/local/share, to run getraw.py type:

    $ export PYTHONPATH=/usr/local/share:$PYTHONPATH
    $ python getraw.py http://www.example.com/

We need to augment PYTHONPATH because Neubot is not installed together
with the system's Python distribution.

It is possible to improve the above example with some error checking,
as follows:

        ...

        def __init__(self, host):
            ...
            neubot.net.connect(host, "80", self.connected,
                             cantconnect=self.cantconnect,
                               connecting=self.connecting)

        def self.connecting(self):
            sys.stderr.write("Connection in progress...\n")

        def self.cantconnect(self):
            sys.stderr.write("Connection failed\n")

        ...

        def connected(self, stream):
            sys.stderr.write("Sending in progress...\n")
            stream.send(self.request, self.sent,
             send_error=self.cantsend)

        def cantsend(self, stream):
            sys.stderr.write("Send failed\n")

        def sent(self, stream, octets):
            sys.stderr.write("Receiving in progress...\n")
            stream.recv(8000, self.received,
             recv_error=self.cantrecv)

        def received(self, stream, octets):
            sys.stdout.write(octets)
            stream.recv(8000, self.received,
             recv_error=self.cantrecv)

        def cantrecv(self, stream):
            if not stream.eof:
                sys.stderr.write("Recv failed\n")
            else:
                sys.stderr.write("Done\n")

        ...

=head1 FILES

Neubot sources are installed in $SHARE, where $SHARE is I</usr/local/share>
when installing from sources, and is I</usr/share> when installing with a
package manager.  In this section we will use $SHARE for generality.

=over 4

=item $SHARE/neubot/net/__init__.py

Exports the interface described in this manual page.

=item $SHARE/neubot/net/connectors.py

Implementation of B<neubot.net.connect()>.

=item $SHARE/neubot/net/listeners.py

Implementation of B<neubot.net.listen()>.

=item $SHARE/neubot/net/pollers.py

Implementation of the B<Poller> class.

=item $SHARE/neubot/net/streams.py

Implementation of the B<Stream> class.

=back

=head1 AUTHOR

Simone Basso <bassosimone@gmail.com>

=head1 COPYRIGHT

 Copyright (c) 2010 NEXA Center for Internet & Society.

 Neubot is free software: you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation, either version
 3 of the License, or (at your option) any later version.

=head1 SEE ALSO

=over 2

=item The Neubot Project L<http://nexa.polito.it/neubot>

=item The Neubot Archives L<http://www.neubot.org:8080/>

=item neubot(1)

=back

=cut
