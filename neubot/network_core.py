# neubot/network_core.py

#
# Copyright (c) 2010, 2011-2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

""" Network core """

#
# Autogenerated
#   from m4/neubot/network_core.m4
#   using ./scripts/m4_to_py
#   by simone
#

#
# Python3-ready: yes
#

import errno
import logging
import os
import socket
import sys

from neubot import six
from neubot import utils_net

class DatagramSocket(object):
    """ Datagram socket object """

    def __init__(self, poller):
        self.sock_poller = poller
        self.sock_recv_param = 0
        self.sock_send_param = None
        self.sock_socket = None

    def sock_bind(self, family, proto, address, port):
        """ Bind at the specified family, proto, address, and port """
        self.sock_socket = socket.socket(family, proto, 0)
        self.sock_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock_socket.setblocking(False)
        try:
            self.sock_socket.bind((address, port))
        except socket.error:
            error = sys.exc_info()[1]
            #
            # Using debug() because, with hybrid dual stack, you never know
            # whether bind() at 0.0.0.0:<port> failed because of your previous
            # attempt with IPv6 or because of another daemon that is already
            # bound at 0.0.0.0:<port>.
            #
            logging.debug("network: bind() failed: %s", error)
            return error
        else:
            return None

    def sock_connect(self, family, proto, address, port):
        """ Connect to the specified family, proto, address, and port """
        #
        # Note: with UDP connect() completes immediately, conversely with TCP
        # you also need to invoke tcp_wait_connected().
        #
        self.sock_socket = socket.socket(family, proto, 0)
        self.sock_socket.setblocking(False)
        try:
            result = self.sock_socket.connect_ex((address, port))
            # Note: Winsock returns EWOULDBLOCK
            if result not in (0, errno.EINPROGRESS, errno.EWOULDBLOCK,
                              errno.EAGAIN):
                raise socket.error(result, os.strerror(result))
        except socket.error:
            error = sys.exc_info()[1]
            logging.warning("network: connect() failed: %s", error)
            return error
        else:
            return None

    def sock_recv(self, count):
        """ Start an asynchronous recv() operation """
        self.sock_recv_param = count
        self.sock_poller.set_read(self)

    def sock_handle_read(self):
        """ Perform the recv() operation """
        self.sock_poller.unset_read(self)
        try:
            data = self.sock_socket.recv(self.sock_recv_param)
        except socket.error:
            error = sys.exc_info()[1]
            if error.args[0] in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINTR):
                self.sock_poller.set_read(self)
            else:
                logging.warning("network: recv() failed: %s", error)
                self.sock_recv_param = 0
                self.sock_recv_complete(error, None)
        else:
            self.sock_recv_param = 0
            self.sock_recv_complete(None, data)

    def sock_recv_complete(self, error, data):
        """ Invoked when recv() is complete """

    def sock_send(self, data):
        """ Start an asynchronous send() operation """
        self.sock_send_param = data
        self.sock_poller.set_write(self)

    def sock_handle_write(self):
        """ Perform the send() operation """
        self.sock_poller.unset_write(self)
        try:
            count = self.sock_socket.send(self.sock_send_param)
        except socket.error:
            error = sys.exc_info()[1]
            if error.args[0] in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINTR):
                self.sock_poller.set_write(self)
            else:
                logging.warning("network: send() failed: %s", error)
                self.sock_send_param = None
                self.sock_send_complete(error, 0)
        else:
            self.sock_send_param = None
            self.sock_send_complete(None, count)

    def sock_send_complete(self, error, count):
        """ Invoked when send() is complete """

    def sock_close(self):
        """ Close this socket """
        self.sock_poller.close(self, 0)

    def sock_handle_close(self, error):
        """ Invoked when the connection is closed """
        logging.debug("network: sock_handle_close(): %s", self)
        try:
            self.sock_socket.close()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            pass

    def sock_handle_periodic(self, ticks):
        """ Simple heartbeat mechanism """

    def sock_getpeername(self):
        """ Return the address of the peer socket """
        return utils_net.getpeername(self.sock_socket)

    def sock_getsockname(self):
        """ Return the address of this socket """
        return utils_net.getsockname(self.sock_socket)

    def sock_fileno(self):
        """ Return the fileno of the socket """
        return self.sock_socket.fileno()

class StreamSocket(object):
    """ Stream socket object """

    #
    # The stream socket is more complex than the datagram socket because the
    # stream socket also keeps track of the connecting/accepting state.
    #

    def __init__(self, poller):
        self.sock_poller = poller
        self.sock_recv_param = 0
        self.sock_send_param = None
        self.sock_socket = None

        self.tcp_accept_pending = 0
        self.tcp_connect_pending = 0

    def sock_bind(self, family, proto, address, port):
        """ Bind at the specified family, proto, address, and port """
        self.sock_socket = socket.socket(family, proto, 0)
        self.sock_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock_socket.setblocking(False)
        try:
            self.sock_socket.bind((address, port))
        except socket.error:
            error = sys.exc_info()[1]
            #
            # Using debug() because, with hybrid dual stack, you never know
            # whether bind() at 0.0.0.0:<port> failed because of your previous
            # attempt with IPv6 or because of another daemon that is already
            # bound at 0.0.0.0:<port>.
            #
            logging.debug("network: bind() failed: %s", error)
            return error
        else:
            return None

    def sock_connect(self, family, proto, address, port):
        """ Connect to the specified family, proto, address, and port """
        #
        # Note: with UDP connect() completes immediately, conversely with TCP
        # you also need to invoke tcp_wait_connected().
        #
        self.sock_socket = socket.socket(family, proto, 0)
        self.sock_socket.setblocking(False)
        try:
            result = self.sock_socket.connect_ex((address, port))
            # Note: Winsock returns EWOULDBLOCK
            if result not in (0, errno.EINPROGRESS, errno.EWOULDBLOCK,
                              errno.EAGAIN):
                raise socket.error(result, os.strerror(result))
        except socket.error:
            error = sys.exc_info()[1]
            logging.warning("network: connect() failed: %s", error)
            return error
        else:
            return None

    def sock_recv(self, count):
        """ Start an asynchronous recv() operation """
        self.sock_recv_param = count
        self.sock_poller.set_read(self)

    def _tcp_recv(self):
        """ Perform the recv() operation """
        self.sock_poller.unset_read(self)
        try:
            data = self.sock_socket.recv(self.sock_recv_param)
        except socket.error:
            error = sys.exc_info()[1]
            if error.args[0] in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINTR):
                self.sock_poller.set_read(self)
            else:
                logging.warning("network: recv() failed: %s", error)
                self.sock_recv_param = 0
                self.sock_recv_complete(error, None)
        else:
            self.sock_recv_param = 0
            self.sock_recv_complete(None, data)

    def sock_recv_complete(self, error, data):
        """ Invoked when recv() is complete """

    def sock_send(self, data):
        """ Start an asynchronous send() operation """
        self.sock_send_param = data
        self.sock_poller.set_write(self)

    def _tcp_send(self):
        """ Perform the send() operation """
        self.sock_poller.unset_write(self)
        try:
            count = self.sock_socket.send(self.sock_send_param)
        except socket.error:
            error = sys.exc_info()[1]
            if error.args[0] in (errno.EAGAIN, errno.EWOULDBLOCK, errno.EINTR):
                self.sock_poller.set_write(self)
            else:
                logging.warning("network: send() failed: %s", error)
                self.sock_send_param = None
                self.sock_send_complete(error, 0)
        else:
            self.sock_send_param = None
            self.sock_send_complete(None, count)

    def sock_send_complete(self, error, count):
        """ Invoked when send() is complete """

    def sock_close(self):
        """ Close this socket """
        self.sock_poller.close(self, 0)

    def sock_handle_close(self, error):
        """ Invoked when the connection is closed """
        logging.debug("network: sock_handle_close(): %s", self)
        try:
            self.sock_socket.close()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            pass

    def sock_handle_periodic(self, ticks):
        """ Simple heartbeat mechanism """

    def sock_getpeername(self):
        """ Return the address of the peer socket """
        return utils_net.getpeername(self.sock_socket)

    def sock_getsockname(self):
        """ Return the address of this socket """
        return utils_net.getsockname(self.sock_socket)

    def sock_fileno(self):
        """ Return the fileno of the socket """
        return self.sock_socket.fileno()

    def tcp_wait_connected(self):
        """ Wait until connect is complete """
        self.sock_poller.set_write(self)
        self.tcp_connect_pending = 1

    def _tcp_connect(self):
        """ Make sure that connect succeeded """
        self.sock_poller.unset_write(self)
        self.tcp_connect_pending = 0

        #
        # We use getpeername() to check whether we established the
        # connection(). If getpeername() succeeds, the connection
        # is OK. Instead, if getpeername() fails and the error
        # indicates that we are not connected, we use recv() to get
        # the actual connect() error; otherwise, if we get another
        # kind of error, we pass such error to the caller.
        #
        # For more information see:
        #
        #   http://cr.yp.to/docs/connect.html
        #
        try:
            utils_net.getpeername(self.sock_socket)
        except socket.error:
            error = sys.exc_info()[1]
            # Note: on MacOSX getpeername() fails with EINVAL
            if error.args[0] in (errno.ENOTCONN, errno.EINVAL):
                try:
                    self.sock_socket.recv(1)
                except socket.error:
                    error = sys.exc_info()[1]
                    logging.warning("network: connect() failed: %s", error)
                    self.tcp_connect_complete(error)
                else:
                    # This really SHOULD NOT happen
                    logging.warning("network: connect() internal error")
                    self.tcp_connect_complete(-1)
            else:
                logging.warning("network: connect() failed: %s", error)
                self.tcp_connect_complete(error)
        else:
            self.tcp_connect_complete(None)

    def tcp_connect_complete(self, error):
        """ Invoked when connect is complete """

    def tcp_listen(self, backlog):
        """ Setup listen queue for socket """
        self.sock_socket.listen(backlog)

    def tcp_wait_accept(self):
        """ Wait until a new client connects """
        self.sock_poller.set_read(self)
        self.tcp_accept_pending = 1

    def _tcp_accept(self):
        """ Accept a new TCP connection """
        self.sock_poller.unset_read(self)
        self.tcp_accept_pending = 0
        try:
            sock = self.sock_socket.accept()[0]
        except socket.error:
            error = sys.exc_info()[1]
            logging.warning("network: accept() failed: %s", error)
            self.tcp_accept_complete(error, None)
            return

        sock.setblocking(False)

        try:
            peername = utils_net.getpeername(sock)
            sockname = utils_net.getsockname(sock)
        except socket.error:
            error = sys.exc_info()[1]
            logging.warning("network: get*name() failed: %s", error)
            self.tcp_accept_complete(error, None)
            return

        logging.debug("network: accept %s <-> %s", sockname, peername)

        #
        # The following statement is very handy in subclasses, but
        # there is the side effect that all subclasses must have the
        # same constructor signature of the basic socket types.
        #
        stream = self.__class__(self.sock_poller)
        stream.sock_socket = sock
        self.tcp_accept_complete(None, stream)

    def tcp_accept_complete(self, error, stream):
        """ Invoked when accept() is complete """

    def sock_handle_read(self):
        """ Handle the read event """
        if not self.tcp_accept_pending:
            self._tcp_recv()
        else:
            self._tcp_accept()

    def sock_handle_write(self):
        """ Handle the write event """
        if not self.tcp_connect_pending:
            self._tcp_send()
        else:
            self._tcp_connect()

class BuffStreamSocket(StreamSocket):
    """ Bufferised stream socket """

    def __init__(self, poller):
        StreamSocket.__init__(self, poller)
        self.buff_flushing = False
        self.buff_ibuff = []
        self.buff_ibuff_count = 0
        self.buff_obuff = []
        self.buff_obuff_count = 0

    def buff_ibuff_append(self, data):
        """ Append data to the ibuff buffer """
        self.buff_ibuff.append(data)
        self.buff_ibuff_count += len(data)

    def buff_ibuff_join(self):
        """ Join data in the ibuff buffer """
        data = six.b("").join(self.buff_ibuff)
        self.buff_ibuff = [data]

    def buff_ibuff_readline(self, join):
        """ Read a line from the input buffer """
        count = 0
        for index, bucket in enumerate(self.buff_ibuff):
            pos = bucket.find(six.b("\n"))
            if pos == -1:
                count += len(bucket)
                continue

            #
            # - We cannot use the buffer interface, because the buckets
            #   will go upstream where they are processed.
            #
            # - We expect the input buffer to contain, typically, less
            #   than 3-5 pieces, therefore we use a list.
            #
            front = bucket[:pos + 1]
            remainder = bucket[pos + 1:]
            result = self.buff_ibuff[:index]
            result.append(front)
            self.buff_ibuff = self.buff_ibuff[index:]
            self.buff_ibuff[0] = remainder

            count += len(result[-1])
            if join:
                result = six.b("").join(result)
            return result, count
        return None, count

    def buff_ibuff_readn(self, pos, join):
        """ Read N bytes from the input buffer """
        for index, bucket in enumerate(self.buff_ibuff):
            if pos > len(bucket):
                pos -= len(bucket)
                continue

            #
            # - We cannot use the buffer interface, because the buckets
            #   will go upstream where they are processed.
            #
            # - We expect the input buffer to contain, typically, less
            #   than 3-5 pieces, therefore we use a list.
            #
            front = bucket[:pos]
            remainder = bucket[pos:]
            result = self.buff_ibuff[:index]
            result.append(front)
            self.buff_ibuff = self.buff_ibuff[index:]
            self.buff_ibuff[0] = remainder

            if join:
                result = six.b("").join(result)
            return result

    def buff_obuff_append(self, data):
        """ Append data to the obuff buffer """
        self.buff_obuff.append(data)
        self.buff_obuff_count += len(data)

    def buff_obuff_join(self):
        """ Join data in the obuff buffer """
        data = six.b("").join(self.buff_obuff)
        self.buff_obuff = [data]

    def buff_obuff_flush(self):
        """ Flush the output buffer """
        if self.buff_flushing:
            return
        self.sock_send(self.buff_obuff[0])
        self.buff_flushing = True

    def sock_send_complete(self, error, count):
        #
        # - To avoid making too many copies of strings, which is never a good
        #   idea performance-wise, we use the buffer interface.
        #
        # - We expect the output buffer to contain, typically, less than 3-5
        #   pieces, therefore we implement the output buffer using a list.
        #
        if error:
            self.buff_flushing = False
            self.buff_flush_complete(error)
            return
        self.buff_obuff[0] = six.buff(self.buff_obuff[0], count)
        if not self.buff_obuff[0]:
            del self.buff_obuff[0]
        if not self.buff_obuff:
            self.buff_flushing = False
            self.buff_flush_complete(None)
            return
        self.sock_send(self.buff_obuff[0])

    def buff_flush_complete(self, error):
        """ Invoked when we flushed the output buffer """

