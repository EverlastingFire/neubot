# neubot/network_select.py

#
# Copyright (c) 2010, 2011-2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

""" Select() based poller """

#
# Autogenerated
#   from m4/neubot/network_select.m4
#   using ./scripts/m4_to_py
#   by simone
#

#
# Python3-ready: yes
#

import errno
import heapq
import logging
import select
import sys
import time

from neubot import utils

class SelectPoller(object):
    """ Select() based poller """

    def __init__(self):
        self.again = 1
        self.channels = {}
        self.readset = {}
        self.tasks = []
        self.timeout = 1
        self.writeset = {}

    def sched(self, delay, function, arg):
        """ Call a function at a later time """
        event = (utils.ticks() + delay, function, arg)
        heapq.heappush(self.tasks, event)
        return event

    def recv_message(self, channel, function):
        """ Wait for a message on the given channel """
        self.channels[channel] = function

    def send_message(self, channel, message):
        """ Send a message on the given channel """
        function = self.channels.pop(channel, None)
        if not function:
            return
        try:
            #
            # We pass the poller to function(), therefore function() can be
            # a plain function and does not need to be an object only to keep
            # a reference to the poller.
            #
            function(self, message)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            logging.warning("poller: function() failed", exc_info=1)

    def set_read(self, sock):
        """ Start monitoring for readability """
        self.readset[sock.sock_fileno()] = sock

    def unset_read(self, sock):
        """ Stop monitoring for readability """
        self.readset.pop(sock.sock_fileno(), None)

    def set_write(self, sock):
        """ Start monitoring for writeability """
        self.writeset[sock.sock_fileno()] = sock

    def unset_write(self, sock):
        """ Stop monitoring for writeability """
        self.writeset.pop(sock.sock_fileno(), None)

    def close(self, sock, error):
        """ Safely close a sock """
        self.unset_read(sock)
        self.unset_write(sock)
        try:
            sock.sock_handle_close(error)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            logging.error("sock_handle_close() failed", exc_info=1)

    def loop(self):
        """ Dispatch I/O and timed events """

        last = utils.ticks()
        while self.again:
            ticks = utils.ticks()

            #
            # 1. Dispatch delayed tasks
            #

            while self.tasks:
                when, function, arg = self.tasks[0]
                if when > ticks:
                    break
                heapq.heappop(self.tasks)
                try:
                    #
                    # We pass the poller to function(), therefore function()
                    # can be a plain function and does not need to be an object
                    # only to keep a reference to the poller.
                    #
                    function(self, arg)
                except (KeyboardInterrupt, SystemExit):
                    raise
                except:
                    logging.warning("poller: function() failed", exc_info=1)

            #
            # We do not want to leave references around for possibly a long
            # time (we do not expect to always have tasks).
            #
            when = None
            function = None
            arg = None

            #
            # 2. Dispatch the periodic event
            #

            if ticks >= last + 10:
                last = ticks
                sockets = set()
                for sock in self.readset.values():
                    sockets.add(sock)
                for sock in self.writeset.values():
                    sockets.add(sock)
                for sock in sockets:
                    try:
                        sock.sock_handle_periodic(ticks)
                    except (KeyboardInterrupt, SystemExit):
                        raise
                    except:
                        logging.warning("poller: sock_handle_periodic(ticks) "
                                        "failed", exc_info=1)
                        self.close(sock, -1)
                sockets = None

            #
            # 3. Dispatch I/O events
            #

            timeout = self.timeout
            if self.tasks:
                timeout = self.tasks[0][0] - ticks
                if timeout < 0:
                    timeout = 0

            if not self.readset and not self.writeset:
                time.sleep(timeout)
                continue

            try:
                res = select.select(list(self.readset), list(self.writeset),
                                    [], timeout)
            except select.error:
                error = sys.exc_info()[1]
                if error.args[0] != errno.EINTR:
                    logging.warning("poller: select() failed: %s", error)
                    time.sleep(1)
                continue
            except (KeyboardInterrupt, SystemExit):
                raise
            except:
                error = sys.exc_info()[1]
                logging.warning("poller: select() failed: %s", error)
                time.sleep(1)
                continue

            for fileno in res[0]:
                sock = self.readset.get(fileno)
                if not sock:
                    continue
                try:
                    sock.sock_handle_read()
                except (KeyboardInterrupt, SystemExit):
                    raise
                except:
                    logging.warning("poller: sock_handle_read() failed",
                                    exc_info=1)
                    self.close(sock, -1)

            for fileno in res[1]:
                sock = self.writeset.get(fileno)
                if not sock:
                    continue
                try:
                    sock.sock_handle_write()
                except (KeyboardInterrupt, SystemExit):
                    raise
                except:
                    logging.warning("poller: sock_handle_write() failed",
                                    exc_info=1)
                    self.close(sock, -1)

    def break_loop(self):
        """ Break the poller loop """
        self.again = 0

