# neubot/http_www.py

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

""" HTTP WWW server """

#
# Autogenerated
#   from m4/neubot/http_www.m4
#   using ./scripts/m4_to_py
#   by simone
#

#
# Python3-ready: yes
#

import email.utils
import logging
import mimetypes
import os.path
import sys
import xml.sax.saxutils

from neubot.http_server import HTTPServer
from neubot.http_server import HTTPSServer

from neubot import six
from neubot import utils_path

HTML_EXTRA_ENTITIES = {'"': "&quot;", "'": "&apos;"}

class HTTPWWWServer(HTTPServer):
    """ HTTP WWW server """

    def __init__(self, poller):
        HTTPServer.__init__(self, poller)
        self.rootdir = None

    def _http_send_error(self, code, reason):
        """ Send an HTTP error response """
        string = "%s %s" % (code, reason)
        string = xml.sax.saxutils.escape(string, HTML_EXTRA_ENTITIES)

        body = []
        body.append("<!DOCTYPE html>\r\n")
        body.append("<HTML>\r\n")
        body.append("  <HEAD>\r\n")
        body.append("    <TITLE>%s</TITLE>\r\n" % string)
        body.append("  </HEAD>\r\n")
        body.append("  <BODY>\r\n")
        body.append("    <H1>%s</H1>\r\n" % string)
        body.append("  </BODY>\r\n")
        body.append("</HTML>\r\n")
        body = "".join(body)
        body = body.encode("UTF-8")

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(len(body)),
            "Content-Type": "text/html; charset=UTF-8",
        }

        self.http_append_response("HTTP/1.1", code,
          reason, headers, body)
        self.buff_obuff_flush()
        self.http_read_headers()

    def _http_listdir(self, normpath):
        """ Lists the content of the selected directory """
        basedir = normpath.replace(self.rootdir, "", 1)
        basedir = xml.sax.saxutils.escape(basedir, HTML_EXTRA_ENTITIES)

        body = []
        body.append("<!DOCTYPE html>\r\n")
        body.append("<HTML>\r\n")
        body.append("  <HEAD>\r\n")
        body.append("    <TITLE>Content of %s/</TITLE>\r\n" % basedir)
        body.append("  </HEAD>\r\n")
        body.append("  <BODY>\r\n")
        body.append("    <H1>Content of %s/</H1>\r\n" % basedir)
        if basedir:
            body.append("    <A HREF=\"%s/..\">../</A><BR>\r\n" % (basedir))

        for name in sorted(os.listdir(normpath)):
            if name.startswith("."):
                continue

            fullpath = os.sep.join([normpath, name])
            if os.path.isdir(fullpath):
                isdir = "/"
            elif os.path.isfile(fullpath):
                isdir = ""
            else:
                continue

            srvrpath = os.sep.join([basedir, name])
            name = xml.sax.saxutils.escape(name, HTML_EXTRA_ENTITIES)
            srvrpath = xml.sax.saxutils.escape(srvrpath, HTML_EXTRA_ENTITIES)

            body.append("    <A HREF=\"%s\">%s%s</A><BR>\r\n" % (
                        srvrpath, name, isdir))

        body.append("  </BODY>\r\n")
        body.append("</HTML>\r\n")
        body = "".join(body)
        body = body.encode("UTF-8")

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(len(body)),
            "Content-Type": "text/html; charset=UTF-8",
        }

        self.http_append_response("HTTP/1.1", "200", "Ok", headers, body)
        self.buff_obuff_flush()
        self.http_read_headers()

    def http_handle_headers(self, error):
        if error:
            self.sock_close()
            return
        self.http_read_body()

    def http_handle_body(self, error):
        if error:
            self.sock_close()
            return

        if (
            self.http_request_protocol == six.b("HTTP/1.1") and
            not self.http_request_headers.get(six.b("host"))
           ):
            logging.warning("http: The host header is missing")
            self._http_send_error("403", "Forbidden")
            return

        if not os.path.isdir(self.rootdir):
            logging.warning("http: the root directory is invalid")
            self._http_send_error("403", "Forbidden")
            return

        if (
            self.http_request_method != six.b("GET") and
            self.http_request_method != six.b("HEAD")
           ):
            logging.warning("http: method not implemented")
            self._http_send_error("501", "Not Implemented")
            return

        if not self.http_request_uri.startswith(six.b("/")):
            logging.warning("http: the request_uri is not an absolute path")
            self._http_send_error("403", "Forbidden")
            return

        normpath = None
        try:
            parsed = six.urlparse.urlsplit(self.http_request_uri)
            normpath = parsed[2].decode("ASCII")
            logging.debug("http: the original URL path is: %s", normpath)
            normpath = six.urllib.unquote(normpath)
            logging.debug("http: the unquoted URL path is: %s", normpath)
            normpath = utils_path.append(self.rootdir, normpath)
            if not normpath:
                raise RuntimeError("cannot append path to rootdir")
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: cannot normalize path: %s", error)
            self._http_send_error("404", "Not Found")
            return

        if os.path.isdir(normpath):
            self._http_listdir(normpath)
            return

        body = None
        try:
            filep = open(normpath, "rb")
            body = filep.read()
            filep.close()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: failed to open file: %s", error)
            self._http_send_error("404", "Not Found")
            return

        content_type = None
        encoding = None
        try:
            content_type, encoding = mimetypes.guess_type(normpath)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: failed to compute size: %s", error)
            self._http_send_error("500", "Internal Server Error")
            return

        content_length = len(body)

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(content_length),
            "Content-Type": content_type,
        }
        if encoding:
            headers["Content-Encoding"] = encoding
        if not headers["Content-Type"]:
            headers["Content-Type"] = "text/plain; charset=UTF-8"
        self.http_append_response("HTTP/1.1", "200", "Ok", headers, None)
        if self.http_request_method == six.b("GET"):
            self.http_append_data(body)

        self.buff_obuff_flush()
        self.http_read_headers()

    def tcp_accept_complete(self, error, stream):
        self.tcp_wait_accept()
        if error:
            return

        stream.rootdir = self.rootdir

        stream.http_read_headers()

class HTTPSWWWServer(HTTPSServer):
    """ HTTPS WWW server """

    def __init__(self, poller):
        HTTPSServer.__init__(self, poller)
        self.certfile = None
        self.rootdir = None

    def _http_send_error(self, code, reason):
        """ Send an HTTP error response """
        string = "%s %s" % (code, reason)
        string = xml.sax.saxutils.escape(string, HTML_EXTRA_ENTITIES)

        body = []
        body.append("<!DOCTYPE html>\r\n")
        body.append("<HTML>\r\n")
        body.append("  <HEAD>\r\n")
        body.append("    <TITLE>%s</TITLE>\r\n" % string)
        body.append("  </HEAD>\r\n")
        body.append("  <BODY>\r\n")
        body.append("    <H1>%s</H1>\r\n" % string)
        body.append("  </BODY>\r\n")
        body.append("</HTML>\r\n")
        body = "".join(body)
        body = body.encode("UTF-8")

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(len(body)),
            "Content-Type": "text/html; charset=UTF-8",
        }

        self.http_append_response("HTTP/1.1", code,
          reason, headers, body)
        self.buff_obuff_flush()
        self.http_read_headers()

    def _http_listdir(self, normpath):
        """ Lists the content of the selected directory """
        basedir = normpath.replace(self.rootdir, "", 1)
        basedir = xml.sax.saxutils.escape(basedir, HTML_EXTRA_ENTITIES)

        body = []
        body.append("<!DOCTYPE html>\r\n")
        body.append("<HTML>\r\n")
        body.append("  <HEAD>\r\n")
        body.append("    <TITLE>Content of %s/</TITLE>\r\n" % basedir)
        body.append("  </HEAD>\r\n")
        body.append("  <BODY>\r\n")
        body.append("    <H1>Content of %s/</H1>\r\n" % basedir)
        if basedir:
            body.append("    <A HREF=\"%s/..\">../</A><BR>\r\n" % (basedir))

        for name in sorted(os.listdir(normpath)):
            if name.startswith("."):
                continue

            fullpath = os.sep.join([normpath, name])
            if os.path.isdir(fullpath):
                isdir = "/"
            elif os.path.isfile(fullpath):
                isdir = ""
            else:
                continue

            srvrpath = os.sep.join([basedir, name])
            name = xml.sax.saxutils.escape(name, HTML_EXTRA_ENTITIES)
            srvrpath = xml.sax.saxutils.escape(srvrpath, HTML_EXTRA_ENTITIES)

            body.append("    <A HREF=\"%s\">%s%s</A><BR>\r\n" % (
                        srvrpath, name, isdir))

        body.append("  </BODY>\r\n")
        body.append("</HTML>\r\n")
        body = "".join(body)
        body = body.encode("UTF-8")

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(len(body)),
            "Content-Type": "text/html; charset=UTF-8",
        }

        self.http_append_response("HTTP/1.1", "200", "Ok", headers, body)
        self.buff_obuff_flush()
        self.http_read_headers()

    def http_handle_headers(self, error):
        if error:
            self.sock_close()
            return
        self.http_read_body()

    def http_handle_body(self, error):
        if error:
            self.sock_close()
            return

        if (
            self.http_request_protocol == six.b("HTTP/1.1") and
            not self.http_request_headers.get(six.b("host"))
           ):
            logging.warning("http: The host header is missing")
            self._http_send_error("403", "Forbidden")
            return

        if not os.path.isdir(self.rootdir):
            logging.warning("http: the root directory is invalid")
            self._http_send_error("403", "Forbidden")
            return

        if (
            self.http_request_method != six.b("GET") and
            self.http_request_method != six.b("HEAD")
           ):
            logging.warning("http: method not implemented")
            self._http_send_error("501", "Not Implemented")
            return

        if not self.http_request_uri.startswith(six.b("/")):
            logging.warning("http: the request_uri is not an absolute path")
            self._http_send_error("403", "Forbidden")
            return

        normpath = None
        try:
            parsed = six.urlparse.urlsplit(self.http_request_uri)
            normpath = parsed[2].decode("ASCII")
            logging.debug("http: the original URL path is: %s", normpath)
            normpath = six.urllib.unquote(normpath)
            logging.debug("http: the unquoted URL path is: %s", normpath)
            normpath = utils_path.append(self.rootdir, normpath)
            if not normpath:
                raise RuntimeError("cannot append path to rootdir")
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: cannot normalize path: %s", error)
            self._http_send_error("404", "Not Found")
            return

        if os.path.isdir(normpath):
            self._http_listdir(normpath)
            return

        body = None
        try:
            filep = open(normpath, "rb")
            body = filep.read()
            filep.close()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: failed to open file: %s", error)
            self._http_send_error("404", "Not Found")
            return

        content_type = None
        encoding = None
        try:
            content_type, encoding = mimetypes.guess_type(normpath)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            error = sys.exc_info()[1]
            logging.warning("http: failed to compute size: %s", error)
            self._http_send_error("500", "Internal Server Error")
            return

        content_length = len(body)

        headers = {
            "Allow": "GET, HEAD",
            "Date": email.utils.formatdate(usegmt=True),
            "Server": "Neubot/0.4.16.0",
            "Content-Length": str(content_length),
            "Content-Type": content_type,
        }
        if encoding:
            headers["Content-Encoding"] = encoding
        if not headers["Content-Type"]:
            headers["Content-Type"] = "text/plain; charset=UTF-8"
        self.http_append_response("HTTP/1.1", "200", "Ok", headers, None)
        if self.http_request_method == six.b("GET"):
            self.http_append_data(body)

        self.buff_obuff_flush()
        self.http_read_headers()

    def tcp_accept_complete(self, error, stream):
        self.tcp_wait_accept()
        if error:
            return

        stream.rootdir = self.rootdir

        stream.ssl_handshake(True, self.certfile)

    def ssl_handshake_complete(self, error):
        if error:
            self.sock_close()
            return
        self.http_read_headers()
