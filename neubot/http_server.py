# neubot/http_server.py

#
# Copyright (c) 2011-2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

""" HTTP servers """

#
# Autogenerated
#   from m4/neubot/http_server.m4
#   using ./scripts/m4_to_py
#   by simone
#

#
# Python3-ready: yes
#

import logging

from neubot.network_core import BuffStreamSocket
from neubot.network_ssl import BuffSSLSocket

from neubot import six

HTTP_ELINETOOLONG = 0
HTTP_ETOOMANYHEADERS = 1
HTTP_ENOHEADERS = 2
###HTTP_ETOOMANYLINES = 3
HTTP_EINVALIDFIRSTLINE = 4
HTTP_EINVALIDPROTOCOL = 5
HTTP_EUNSUPPORTEDVERSION = 6
HTTP_EINVALIDHEADER = 7
HTTP_ESOCKET = 8
HTTP_EEOF = 9
HTTP_EINVALIDLENGTH = 10
HTTP_ENEGATIVELENGTH = 11
HTTP_EINVALIDCHUNKLEN = 12
HTTP_ENEGATIVECHUNKLEN = 13
HTTP_EINVALIDCHUNKEND = 14
HTTP_EINTERNAL = 15
###HTTP_EINVALIDREQUEST = 16

HTTP_MAX_HEADERS = 128
HTTP_MAX_LINE_LENGTH = 512
HTTP_PIECE_MAX = 1 << 22
HTTP_RECV_MAX = 1 << 18

class HTTPServer(BuffStreamSocket):
    """ HTTP server """

    def __init__(self, poller):
        logging.debug("http: init %s", self)
        BuffStreamSocket.__init__(self, poller)
        self.http_chunked_state = 0
        self.http_left = 0

        # We save these fields just in case they are useful
        self.http_response_protocol = six.b("")
        self.http_response_code = six.b("")
        self.http_response_reason = six.b("")
        self.http_response_headers = {}

        self.http_request_lines = []
        self.http_request_method = six.b("")
        self.http_request_uri = six.b("")
        self.http_request_protocol = six.b("")
        self.http_request_headers = {}
        self.http_request_body = []
        self.http_request_trailers = {}

    def sock_handle_close(self, error):
        BuffStreamSocket.sock_handle_close(self, error)
        logging.debug("http: sock_handle_close(): %s", self)
        #
        # Remove the self-reference, therefore we do not need to wait for the
        # garbage collector, which, depending on the memory pressure may never
        # run (especially when we have few objects).
        #
        self.sock_recv_complete = None

    def __del__(self):
        logging.debug("http: del %s", self)

    def http_read_headers(self):
        """ Read request headers """
        self.http_request_lines = []
        self.http_request_method = six.b("")
        self.http_request_uri = six.b("")
        self.http_request_protocol = six.b("")
        self.http_request_headers = {}
        self._http_read_headers_loop()

    def _http_read_headers_loop(self):
        """ Loop that reads request headers """

        while True:
            line, count = self.buff_ibuff_readline(True)
            if not line:
                if count > HTTP_MAX_LINE_LENGTH:
                    logging.warning("http: line too long")
                    self.http_handle_headers(HTTP_ELINETOOLONG)
                    return
                self.sock_recv_complete = self._http_read_headers_hook
                self.sock_recv(HTTP_RECV_MAX)
                return
            line = line.rstrip()
            logging.debug("< %s", line)
            if not line:
                break
            self.http_request_lines.append(line)
            if len(self.http_request_lines) > HTTP_MAX_HEADERS:
                logging.warning("http: received too many headers")
                self.http_handle_headers(HTTP_ETOOMANYHEADERS)
                return

        #
        # Grok request line
        #

        if not self.http_request_lines:
            logging.warning("http: received no headers")
            self.http_handle_headers(HTTP_ENOHEADERS)
            return

        line = self.http_request_lines[0]
        vector = line.split(None, 2)
        if len(vector) != 3:
            logging.warning("http: invalid first line")
            self.http_handle_headers(HTTP_EINVALIDFIRSTLINE)
            return

        self.http_request_method = vector[0]
        self.http_request_uri = vector[1]
        self.http_request_protocol = vector[2]

        if not self.http_request_protocol.startswith(six.b("HTTP/")):
            logging.warning("http: invalid protocol")
            self.http_handle_headers(HTTP_EINVALIDPROTOCOL)
            return

        if self.http_request_protocol[5:] not in (six.b("1.1"), six.b("1.0")):
            logging.warning("http: unsupported protocol version")
            self.http_handle_headers(HTTP_EUNSUPPORTEDVERSION)
            return

        #
        # Grok request headers (or trailers)
        #

        last_header = None
        for line in self.http_request_lines[1:]:

            #
            # Line folding. Must preceed header parsing, otherwise one
            # cannot send the colon character in folded lines.
            #
            if last_header and line[0:1] in (six.b(" "), six.b("\t")):
                value  = self.http_request_headers[last_header]
                value += six.b(" ")
                value += line.strip()
                # Make sure there are no leading or trailing spaces
                self.http_request_headers[last_header] = value.strip()
                continue

            index = line.find(six.b(":"))
            if index >= 0:
                name, value = line.split(six.b(":"), 1)
                name = name.strip().lower()
                value = value.strip()
                if name not in self.http_request_headers:
                    self.http_request_headers[name] = value
                else:
                    #
                    # For headers whose value is a list of
                    # comma-separated values, multiple headers
                    # with the same name are equivalent to a
                    # comma-separated list of values.
                    #     (See: RFC2616, sect. 4.2)
                    #
                    self.http_request_headers[name] += six.b(", ")
                    self.http_request_headers[name] += value
                last_header = name
                continue

            logging.warning("http: received invalid header line")
            self.http_handle_headers(HTTP_EINVALIDHEADER)
            return

        self.http_handle_headers(0)

    def _http_read_headers_hook(self, error, data):
        """ Socket-level hook for reading request headers """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_headers(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_headers(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_headers_loop()

    def http_handle_headers(self, error):
        """ We have read request headers """

    def http_read_body(self):
        """ Read the HTTP request body """

        self.http_request_body = []
        self.http_request_lines = []
        self.http_request_trailers = {}

        # Also reset the two state variables for consistency
        self.http_chunked_state = 0
        self.http_left = 0

        tmp = self.http_request_headers.get(six.b("transfer-encoding"))
        if tmp == six.b("chunked"):
            logging.debug("http: there is a chunked message body")
            self._http_read_chunked()
            return

        tmp = self.http_request_headers.get(six.b("content-length"))
        if tmp:
            try:
                length = int(tmp)
            except ValueError:
                logging.warning("http: invalid Content-Length header")
                self.http_handle_body(HTTP_EINVALIDLENGTH)
                return

            if length > 0:
                logging.debug("http: there is a bounded message body")
                self._http_read_bounded(length)
                return
            if length == 0:
                logging.debug("http: the message body is empty")
                self.http_handle_body(0)
                return

            logging.warning("http: negative Content-Length header")
            self.http_handle_body(HTTP_ENEGATIVELENGTH)
            return

        logging.debug("http: assuming that the body is empty")
        self.http_handle_body(0)

    def http_handle_body(self, error):
        """ We have received all the body """

    def http_handle_body_part(self):
        """ We have received a part of the body """

    def _http_read_bounded(self, amount):
        """ Read the bounded request body """
        self.http_left = amount
        self._http_read_bounded_loop()

    def _http_read_bounded_loop(self):
        """ Loop that reads the bounded request body """
        while True:
            amount = min(self.http_left, HTTP_PIECE_MAX)
            vector = self.buff_ibuff_readn(amount, False)
            if not vector:
                self.sock_recv_complete = self._http_read_bounded_hook
                self.sock_recv(HTTP_RECV_MAX)
                return
            for data in vector:
                self.http_left -= len(data)
                self.http_request_body.append(data)
            self.http_handle_body_part()
            if self.http_left <= 0:
                break
        self.http_handle_body(0)

    def _http_read_bounded_hook(self, error, data):
        """ Socket-level hook for reading the bounded request body """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_body(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_body(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_bounded_loop()

    def _http_read_chunked(self):
        """ Read chunked request body """
        self.http_chunked_state = 1
        self._http_read_chunked_loop()

    def _http_read_chunked_loop(self):
        """ Loop that reads the chunked request body """
        while True:

            if self.http_chunked_state == 1:
                line, count = self.buff_ibuff_readline(True)
                if not line:
                    if count > HTTP_MAX_LINE_LENGTH:
                        logging.warning("http: line too long")
                        self.http_handle_body(HTTP_ELINETOOLONG)
                        return
                    self.sock_recv_complete = self._http_read_chunked_hook
                    self.sock_recv(HTTP_RECV_MAX)
                    return
                line = line.rstrip()
                logging.debug("< %s", line)

                vector = line.split()
                if not vector:
                    logging.warning("http: invalid chunk-length line")
                    self.http_handle_body(HTTP_EINVALIDCHUNKLEN)
                    return
                try:
                    tmp = int(vector[0], 16)
                except ValueError:
                    logging.warning("http: invalid chunk-length token")
                    self.http_handle_body(HTTP_EINVALIDCHUNKLEN)
                    return
                if tmp < 0:
                    logging.warning("http: negative chunk-length token")
                    self.http_handle_body(HTTP_ENEGATIVECHUNKLEN)
                    return

                if tmp > 0:
                    logging.debug("< {chunk len=%d}", tmp)
                    self.http_left = tmp
                    self.http_chunked_state = 2
                else:
                    logging.debug("< {last-chunk/}")
                    self.http_chunked_state = 4

            elif self.http_chunked_state == 2:
                while True:
                    amount = min(self.http_left, HTTP_PIECE_MAX)
                    vector = self.buff_ibuff_readn(amount, False)
                    if not vector:
                        self.sock_recv_complete = self._http_read_chunked_hook
                        self.sock_recv(HTTP_RECV_MAX)
                        return
                    for data in vector:
                        self.http_left -= len(data)
                        self.http_request_body.append(data)
                    self.http_handle_body_part()
                    if self.http_left <= 0:
                        break
                self.http_chunked_state = 3

            elif self.http_chunked_state == 3:
                line, count = self.buff_ibuff_readline(True)
                if not line:
                    if count > HTTP_MAX_LINE_LENGTH:
                        logging.warning("http: line too long")
                        self.http_handle_body(HTTP_ELINETOOLONG)
                        return
                    self.sock_recv_complete = self._http_read_chunked_hook
                    self.sock_recv(HTTP_RECV_MAX)
                    return
                line = line.rstrip()
                logging.debug("< %s", line)

                if line:
                    logging.warning("http: invalid chunk-end line")
                    self.http_handle_body(HTTP_EINVALIDCHUNKEND)
                    return
                logging.debug("< {/chunk}")
                self.http_chunked_state = 1

            elif self.http_chunked_state == 4:
                while True:
                    line, count = self.buff_ibuff_readline(True)
                    if not line:
                        if count > HTTP_MAX_LINE_LENGTH:
                            logging.warning("http: line too long")
                            self.http_handle_body(HTTP_ELINETOOLONG)
                            return
                        self.sock_recv_complete = self._http_read_chunked_hook
                        self.sock_recv(HTTP_RECV_MAX)
                        return
                    line = line.rstrip()
                    logging.debug("< %s", line)
                    if not line:
                        break
                    self.http_request_lines.append(line)
                    if len(self.http_request_lines) > HTTP_MAX_HEADERS:
                        logging.warning("http: received too many headers")
                        self.http_handle_body(HTTP_ETOOMANYHEADERS)
                        return

                #
                # Grok request headers (or trailers)
                #

                last_header = None
                for line in self.http_request_lines[1:]:

                    #
                    # Line folding. Must preceed header parsing, otherwise one
                    # cannot send the colon character in folded lines.
                    #
                    if last_header and line[0:1] in (six.b(" "), six.b("\t")):
                        value  = self.http_request_trailers[last_header]
                        value += six.b(" ")
                        value += line.strip()
                        # Make sure there are no leading or trailing spaces
                        self.http_request_trailers[last_header] = value.strip()
                        continue

                    index = line.find(six.b(":"))
                    if index >= 0:
                        name, value = line.split(six.b(":"), 1)
                        name = name.strip().lower()
                        value = value.strip()
                        if name not in self.http_request_trailers:
                            self.http_request_trailers[name] = value
                        else:
                            #
                            # For headers whose value is a list of
                            # comma-separated values, multiple headers
                            # with the same name are equivalent to a
                            # comma-separated list of values.
                            #     (See: RFC2616, sect. 4.2)
                            #
                            self.http_request_trailers[name] += six.b(", ")
                            self.http_request_trailers[name] += value
                        last_header = name
                        continue

                    logging.warning("http: received invalid header line")
                    self.http_handle_body(HTTP_EINVALIDHEADER)
                    return

                self.http_handle_body(0)
                return

            else:
                logging.warning("http: chunked internal error")
                self.http_handle_body(HTTP_EINTERNAL)
                return

    def _http_read_chunked_hook(self, error, data):
        """ Socket-level hook for reading chunked request body """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_body(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_body(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_chunked_loop()

    #
    # This class only contains the methods to append HTTP data to the output
    # buffer, please use self.buff_obuff_*() to start flushing the ouput buffer
    # and to be notified when the flush operation is complete.
    #

    def http_append_response(self, protocol, code, reason, headers, body):
        """ Append response to output buffer """
        vector = []

        self.http_response_protocol = six.b(protocol)
        self.http_response_code = six.b(code)
        self.http_response_reason = six.b(reason)

        response_line = six.b(" ").join([self.http_response_protocol,
          self.http_response_code, self.http_response_reason])
        logging.debug("> %s", response_line)
        vector.append(response_line)
        vector.append(six.b("\r\n"))

        self.http_response_headers = {}
        for name, value in headers.items():
            name = six.b(name.strip())
            value = six.b(value.strip())
            header = six.b(": ").join([name, value])
            logging.debug("> %s", header)
            self.http_response_headers[name] = value
            vector.append(header)
            vector.append(six.b("\r\n"))

        logging.debug("> ")
        vector.append(six.b("\r\n"))

        if body:
            vector.append(body)

        message = six.b("").join(vector)
        self.buff_obuff_append(message)

    def http_append_data(self, data):
        """ Append data to output buffer """
        self.buff_obuff_append(data)

    def http_append_chunk(self, data):
        """ Append chunk to output buffer """
        vector = []
        logging.debug("> {chunk len=%d}", len(data))
        vector.append(six.b("%x\r\n" % len(data)))
        vector.append(data)
        vector.append(six.b("\r\n"))
        bytez = six.b("").join(vector)
        self.buff_obuff_append(bytez)

    def http_append_last_chunk(self, trailers):
        """ Append the last chunk to output buffer """
        vector = []
        logging.debug("> {last-chunk}")
        vector.append(six.b("0\r\n"))
        for name, value in trailers.items():
            name = six.b(name.strip())
            value = six.b(value.strip())
            trailer = six.b(": ").join([name, value])
            logging.debug("> %s", trailer)
            vector.append(trailer)
            vector.append(six.b("\r\n"))

        vector.append(six.b("\r\n"))
        bytez = six.b("").join(vector)
        self.buff_obuff_append(bytez)

class HTTPSServer(BuffSSLSocket):
    """ HTTPS server """

    def __init__(self, poller):
        logging.debug("http: init %s", self)
        BuffSSLSocket.__init__(self, poller)
        self.http_chunked_state = 0
        self.http_left = 0

        # We save these fields just in case they are useful
        self.http_response_protocol = six.b("")
        self.http_response_code = six.b("")
        self.http_response_reason = six.b("")
        self.http_response_headers = {}

        self.http_request_lines = []
        self.http_request_method = six.b("")
        self.http_request_uri = six.b("")
        self.http_request_protocol = six.b("")
        self.http_request_headers = {}
        self.http_request_body = []
        self.http_request_trailers = {}

    def sock_handle_close(self, error):
        BuffSSLSocket.sock_handle_close(self, error)
        logging.debug("http: sock_handle_close(): %s", self)
        #
        # Remove the self-reference, therefore we do not need to wait for the
        # garbage collector, which, depending on the memory pressure may never
        # run (especially when we have few objects).
        #
        self.sock_recv_complete = None

    def __del__(self):
        logging.debug("http: del %s", self)

    def http_read_headers(self):
        """ Read request headers """
        self.http_request_lines = []
        self.http_request_method = six.b("")
        self.http_request_uri = six.b("")
        self.http_request_protocol = six.b("")
        self.http_request_headers = {}
        self._http_read_headers_loop()

    def _http_read_headers_loop(self):
        """ Loop that reads request headers """

        while True:
            line, count = self.buff_ibuff_readline(True)
            if not line:
                if count > HTTP_MAX_LINE_LENGTH:
                    logging.warning("http: line too long")
                    self.http_handle_headers(HTTP_ELINETOOLONG)
                    return
                self.sock_recv_complete = self._http_read_headers_hook
                self.sock_recv(HTTP_RECV_MAX)
                return
            line = line.rstrip()
            logging.debug("< %s", line)
            if not line:
                break
            self.http_request_lines.append(line)
            if len(self.http_request_lines) > HTTP_MAX_HEADERS:
                logging.warning("http: received too many headers")
                self.http_handle_headers(HTTP_ETOOMANYHEADERS)
                return

        #
        # Grok request line
        #

        if not self.http_request_lines:
            logging.warning("http: received no headers")
            self.http_handle_headers(HTTP_ENOHEADERS)
            return

        line = self.http_request_lines[0]
        vector = line.split(None, 2)
        if len(vector) != 3:
            logging.warning("http: invalid first line")
            self.http_handle_headers(HTTP_EINVALIDFIRSTLINE)
            return

        self.http_request_method = vector[0]
        self.http_request_uri = vector[1]
        self.http_request_protocol = vector[2]

        if not self.http_request_protocol.startswith(six.b("HTTP/")):
            logging.warning("http: invalid protocol")
            self.http_handle_headers(HTTP_EINVALIDPROTOCOL)
            return

        if self.http_request_protocol[5:] not in (six.b("1.1"), six.b("1.0")):
            logging.warning("http: unsupported protocol version")
            self.http_handle_headers(HTTP_EUNSUPPORTEDVERSION)
            return

        #
        # Grok request headers (or trailers)
        #

        last_header = None
        for line in self.http_request_lines[1:]:

            #
            # Line folding. Must preceed header parsing, otherwise one
            # cannot send the colon character in folded lines.
            #
            if last_header and line[0:1] in (six.b(" "), six.b("\t")):
                value  = self.http_request_headers[last_header]
                value += six.b(" ")
                value += line.strip()
                # Make sure there are no leading or trailing spaces
                self.http_request_headers[last_header] = value.strip()
                continue

            index = line.find(six.b(":"))
            if index >= 0:
                name, value = line.split(six.b(":"), 1)
                name = name.strip().lower()
                value = value.strip()
                if name not in self.http_request_headers:
                    self.http_request_headers[name] = value
                else:
                    #
                    # For headers whose value is a list of
                    # comma-separated values, multiple headers
                    # with the same name are equivalent to a
                    # comma-separated list of values.
                    #     (See: RFC2616, sect. 4.2)
                    #
                    self.http_request_headers[name] += six.b(", ")
                    self.http_request_headers[name] += value
                last_header = name
                continue

            logging.warning("http: received invalid header line")
            self.http_handle_headers(HTTP_EINVALIDHEADER)
            return

        self.http_handle_headers(0)

    def _http_read_headers_hook(self, error, data):
        """ Socket-level hook for reading request headers """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_headers(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_headers(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_headers_loop()

    def http_handle_headers(self, error):
        """ We have read request headers """

    def http_read_body(self):
        """ Read the HTTP request body """

        self.http_request_body = []
        self.http_request_lines = []
        self.http_request_trailers = {}

        # Also reset the two state variables for consistency
        self.http_chunked_state = 0
        self.http_left = 0

        tmp = self.http_request_headers.get(six.b("transfer-encoding"))
        if tmp == six.b("chunked"):
            logging.debug("http: there is a chunked message body")
            self._http_read_chunked()
            return

        tmp = self.http_request_headers.get(six.b("content-length"))
        if tmp:
            try:
                length = int(tmp)
            except ValueError:
                logging.warning("http: invalid Content-Length header")
                self.http_handle_body(HTTP_EINVALIDLENGTH)
                return

            if length > 0:
                logging.debug("http: there is a bounded message body")
                self._http_read_bounded(length)
                return
            if length == 0:
                logging.debug("http: the message body is empty")
                self.http_handle_body(0)
                return

            logging.warning("http: negative Content-Length header")
            self.http_handle_body(HTTP_ENEGATIVELENGTH)
            return

        logging.debug("http: assuming that the body is empty")
        self.http_handle_body(0)

    def http_handle_body(self, error):
        """ We have received all the body """

    def http_handle_body_part(self):
        """ We have received a part of the body """

    def _http_read_bounded(self, amount):
        """ Read the bounded request body """
        self.http_left = amount
        self._http_read_bounded_loop()

    def _http_read_bounded_loop(self):
        """ Loop that reads the bounded request body """
        while True:
            amount = min(self.http_left, HTTP_PIECE_MAX)
            vector = self.buff_ibuff_readn(amount, False)
            if not vector:
                self.sock_recv_complete = self._http_read_bounded_hook
                self.sock_recv(HTTP_RECV_MAX)
                return
            for data in vector:
                self.http_left -= len(data)
                self.http_request_body.append(data)
            self.http_handle_body_part()
            if self.http_left <= 0:
                break
        self.http_handle_body(0)

    def _http_read_bounded_hook(self, error, data):
        """ Socket-level hook for reading the bounded request body """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_body(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_body(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_bounded_loop()

    def _http_read_chunked(self):
        """ Read chunked request body """
        self.http_chunked_state = 1
        self._http_read_chunked_loop()

    def _http_read_chunked_loop(self):
        """ Loop that reads the chunked request body """
        while True:

            if self.http_chunked_state == 1:
                line, count = self.buff_ibuff_readline(True)
                if not line:
                    if count > HTTP_MAX_LINE_LENGTH:
                        logging.warning("http: line too long")
                        self.http_handle_body(HTTP_ELINETOOLONG)
                        return
                    self.sock_recv_complete = self._http_read_chunked_hook
                    self.sock_recv(HTTP_RECV_MAX)
                    return
                line = line.rstrip()
                logging.debug("< %s", line)

                vector = line.split()
                if not vector:
                    logging.warning("http: invalid chunk-length line")
                    self.http_handle_body(HTTP_EINVALIDCHUNKLEN)
                    return
                try:
                    tmp = int(vector[0], 16)
                except ValueError:
                    logging.warning("http: invalid chunk-length token")
                    self.http_handle_body(HTTP_EINVALIDCHUNKLEN)
                    return
                if tmp < 0:
                    logging.warning("http: negative chunk-length token")
                    self.http_handle_body(HTTP_ENEGATIVECHUNKLEN)
                    return

                if tmp > 0:
                    logging.debug("< {chunk len=%d}", tmp)
                    self.http_left = tmp
                    self.http_chunked_state = 2
                else:
                    logging.debug("< {last-chunk/}")
                    self.http_chunked_state = 4

            elif self.http_chunked_state == 2:
                while True:
                    amount = min(self.http_left, HTTP_PIECE_MAX)
                    vector = self.buff_ibuff_readn(amount, False)
                    if not vector:
                        self.sock_recv_complete = self._http_read_chunked_hook
                        self.sock_recv(HTTP_RECV_MAX)
                        return
                    for data in vector:
                        self.http_left -= len(data)
                        self.http_request_body.append(data)
                    self.http_handle_body_part()
                    if self.http_left <= 0:
                        break
                self.http_chunked_state = 3

            elif self.http_chunked_state == 3:
                line, count = self.buff_ibuff_readline(True)
                if not line:
                    if count > HTTP_MAX_LINE_LENGTH:
                        logging.warning("http: line too long")
                        self.http_handle_body(HTTP_ELINETOOLONG)
                        return
                    self.sock_recv_complete = self._http_read_chunked_hook
                    self.sock_recv(HTTP_RECV_MAX)
                    return
                line = line.rstrip()
                logging.debug("< %s", line)

                if line:
                    logging.warning("http: invalid chunk-end line")
                    self.http_handle_body(HTTP_EINVALIDCHUNKEND)
                    return
                logging.debug("< {/chunk}")
                self.http_chunked_state = 1

            elif self.http_chunked_state == 4:
                while True:
                    line, count = self.buff_ibuff_readline(True)
                    if not line:
                        if count > HTTP_MAX_LINE_LENGTH:
                            logging.warning("http: line too long")
                            self.http_handle_body(HTTP_ELINETOOLONG)
                            return
                        self.sock_recv_complete = self._http_read_chunked_hook
                        self.sock_recv(HTTP_RECV_MAX)
                        return
                    line = line.rstrip()
                    logging.debug("< %s", line)
                    if not line:
                        break
                    self.http_request_lines.append(line)
                    if len(self.http_request_lines) > HTTP_MAX_HEADERS:
                        logging.warning("http: received too many headers")
                        self.http_handle_body(HTTP_ETOOMANYHEADERS)
                        return

                #
                # Grok request headers (or trailers)
                #

                last_header = None
                for line in self.http_request_lines[1:]:

                    #
                    # Line folding. Must preceed header parsing, otherwise one
                    # cannot send the colon character in folded lines.
                    #
                    if last_header and line[0:1] in (six.b(" "), six.b("\t")):
                        value  = self.http_request_trailers[last_header]
                        value += six.b(" ")
                        value += line.strip()
                        # Make sure there are no leading or trailing spaces
                        self.http_request_trailers[last_header] = value.strip()
                        continue

                    index = line.find(six.b(":"))
                    if index >= 0:
                        name, value = line.split(six.b(":"), 1)
                        name = name.strip().lower()
                        value = value.strip()
                        if name not in self.http_request_trailers:
                            self.http_request_trailers[name] = value
                        else:
                            #
                            # For headers whose value is a list of
                            # comma-separated values, multiple headers
                            # with the same name are equivalent to a
                            # comma-separated list of values.
                            #     (See: RFC2616, sect. 4.2)
                            #
                            self.http_request_trailers[name] += six.b(", ")
                            self.http_request_trailers[name] += value
                        last_header = name
                        continue

                    logging.warning("http: received invalid header line")
                    self.http_handle_body(HTTP_EINVALIDHEADER)
                    return

                self.http_handle_body(0)
                return

            else:
                logging.warning("http: chunked internal error")
                self.http_handle_body(HTTP_EINTERNAL)
                return

    def _http_read_chunked_hook(self, error, data):
        """ Socket-level hook for reading chunked request body """
        if error:
            logging.warning("http: socket-level error")
            self.http_handle_body(HTTP_ESOCKET)
            return
        if not data:
            self.http_handle_body(HTTP_EEOF)
            return
        self.buff_ibuff_append(data)
        self._http_read_chunked_loop()

    #
    # This class only contains the methods to append HTTP data to the output
    # buffer, please use self.buff_obuff_*() to start flushing the ouput buffer
    # and to be notified when the flush operation is complete.
    #

    def http_append_response(self, protocol, code, reason, headers, body):
        """ Append response to output buffer """
        vector = []

        self.http_response_protocol = six.b(protocol)
        self.http_response_code = six.b(code)
        self.http_response_reason = six.b(reason)

        response_line = six.b(" ").join([self.http_response_protocol,
          self.http_response_code, self.http_response_reason])
        logging.debug("> %s", response_line)
        vector.append(response_line)
        vector.append(six.b("\r\n"))

        self.http_response_headers = {}
        for name, value in headers.items():
            name = six.b(name.strip())
            value = six.b(value.strip())
            header = six.b(": ").join([name, value])
            logging.debug("> %s", header)
            self.http_response_headers[name] = value
            vector.append(header)
            vector.append(six.b("\r\n"))

        logging.debug("> ")
        vector.append(six.b("\r\n"))

        if body:
            vector.append(body)

        message = six.b("").join(vector)
        self.buff_obuff_append(message)

    def http_append_data(self, data):
        """ Append data to output buffer """
        self.buff_obuff_append(data)

    def http_append_chunk(self, data):
        """ Append chunk to output buffer """
        vector = []
        logging.debug("> {chunk len=%d}", len(data))
        vector.append(six.b("%x\r\n" % len(data)))
        vector.append(data)
        vector.append(six.b("\r\n"))
        bytez = six.b("").join(vector)
        self.buff_obuff_append(bytez)

    def http_append_last_chunk(self, trailers):
        """ Append the last chunk to output buffer """
        vector = []
        logging.debug("> {last-chunk}")
        vector.append(six.b("0\r\n"))
        for name, value in trailers.items():
            name = six.b(name.strip())
            value = six.b(value.strip())
            trailer = six.b(": ").join([name, value])
            logging.debug("> %s", trailer)
            vector.append(trailer)
            vector.append(six.b("\r\n"))

        vector.append(six.b("\r\n"))
        bytez = six.b("").join(vector)
        self.buff_obuff_append(bytez)

