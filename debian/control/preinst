#!/usr/bin/python

#
# Copyright (c) 2011 Marco Scopesi <marco.scopesi@gmail.com>
# Copyright (c) 2011 Simone Basso <bassosimone@gmail.com>
#  NEXA Center for Internet & Society at Politecnico di Torino
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#


'''
 Pre installation script for the debian environment that makes
 sure that the user has read the privacy policy and that she has
 provided the permissions we need.
'''

#
# I know that it's not common to author a preinst script using
# the Python language.  But the problem here is that we need to
# ask for privacy permissions before installing Neubot.  And
# the preinst script seems to me the right place to do this thing.
#

#
# Under debian python depends on libcurses so we can trust
# that ``import curses`` will work.  The dependence on gtk2
# and webkit bindings is satisfied under Ubuntu.  We can
# safely fallback to curses for others.
# It is not possible to use this file under Win32 because
# both curses and syslog are not available.
# In theory this script should work under MacOS, but only
# in textual mode.
#
import asyncore
import curses
import getopt
import os
import sqlite3
import sys
import syslog

syslog.openlog('neubot/preinst',
               syslog.LOG_PID|syslog.LOG_NDELAY|syslog.LOG_PERROR,
               syslog.LOG_USER)

#
# We use gtk and webkit if they are available and
# the DISPLAY variable is set, meaning that the user
# is installing/upgrading from a X11 session.
# We do not import Gtk unless we know we're into
# an X11 session to avoid a warning.
#
USECURSES = True
if 'DISPLAY' in os.environ:
    try:
        import gtk, webkit
    except ImportError:
        ERROR = str(asyncore.compact_traceback())
        syslog.syslog(syslog.LOG_INFO, 'Import error: %s' % ERROR)
    else:
        USECURSES = False

syslog.syslog(syslog.LOG_INFO, 'USECURSES: %d' % USECURSES)

#
# ===================
# Privacy policy text
# ===================
#

BASE_POLICY = '''\
 $Privacy-Policy: 2.0$

 Neubot characterizes your connections via active tests that send and receive
 random data only.  To process and save the results Neubot needs your
 permission because they contain your Internet address.  And that is personal
 data under European and Italian Privacy laws (Decree 196/03).  Please, note
 that without the permission to save the results Neubot cannot work at all.

 Neubot would also like to publish the raw results, to allow other individuals
 and institutions to reuse them for research purposes.  Again, that cannot be
 done without your consent.  While Neubot can work also without the permission
 to publish, please consider providing it: there is a great value in allowing
 other researchers and netizens to study the results.'''

TEXT_POLICY = '''\
Neubot 0.4.2 -- Human-friendly privacy policy

%s

Full privacy policy: <http://www.neubot.org/privacy>
Decree 196/03: <http://www.garanteprivacy.it/garante/doc.jsp?ID=1311248>

Type "ic" to assert you have read the policy and give the permission to
collect, "icp" to assert you have read the policy and give the permission
to collect and publish.  Type "q" to abort installation.

Your choice: ''' % BASE_POLICY

HTML_POLICY = '''\
<HTML>
 <HEAD>
  <TITLE>Human-friendly privacy policy</TITLE>
 <HEAD>
 <BODY>
  <H1>Human-friendly privacy policy</H1>
  <PRE>
%s

Full privacy policy: &lt;http://www.neubot.org/privacy&gt;
Decree 196/03: &lt;http://www.garanteprivacy.it/garante/doc.jsp?ID=1311248&gt;
  </PRE>
 </BODY>
</HTML>''' % BASE_POLICY

#
# =====================
# Gtk and WebKit dialog
# =====================
#

def __update_buttons(widget, informed_button, collect_button,
                   publish_button, ok_button):

    '''
     Called when the user clicks on 'informed' or 'collect'
     check buttons
    '''

    if informed_button.get_active() and collect_button.get_active():
        publish_button.set_sensitive(True)
        ok_button.set_sensitive(True)
    else:
        publish_button.set_sensitive(False)
        publish_button.set_active(False)
        ok_button.set_sensitive(False)

def __show_gtk_dialog():

    ''' Uses Gtk libraries to ask for privacy permissions '''

    #
    # WARNING This script is running as root so we MUST NOT
    # provide clickable links for obvious reasons.
    # I put this warning here because an early beta version of
    # this file allowed the user to click, redirecting the click
    # on the default browser.
    #                           -- Simone (2011/09/27)
    #

    dialog = gtk.Dialog('Neubot 0.4.2 Privacy Policy', None,
        gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
        (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
        gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
    dialog.set_size_request(700, 480)

    scrolled = gtk.ScrolledWindow()
    frame = gtk.Frame()
    frame.add(scrolled)
    dialog.vbox.pack_start(frame)

    browser = webkit.WebView()
    scrolled.add(browser)
    browser.load_string(HTML_POLICY, 'text/html', 'utf-8', '')

    ok_button = dialog.action_area.children()[0]
    ok_button.set_sensitive(False)
    informed_button = gtk.CheckButton('I have read the privacy policy')
    publish_button = gtk.CheckButton('I give Neubot the permission to publish')
    publish_button.set_sensitive(False)
    collect_button = gtk.CheckButton('I give Neubot the permission to collect')

    #
    # We MUST react when ANY of the two fundamental permissions
    # that we need is clicked.
    #
    informed_button.connect('clicked', __update_buttons, informed_button,
                     collect_button, publish_button, ok_button)
    collect_button.connect('clicked', __update_buttons, informed_button,
                     collect_button, publish_button, ok_button)

    vbox_small = gtk.VBox(True)
    vbox_small.pack_start(informed_button)
    vbox_small.pack_start(collect_button)
    vbox_small.pack_start(publish_button)
    dialog.vbox.pack_start(vbox_small, False)

    dialog.show_all()
    response = dialog.run()
    dialog.destroy()

    if response != gtk.RESPONSE_ACCEPT:
        raise RuntimeError('User aborted installation')
    else:
        # We MUST return integers, not strings
        return {
            'informed': int(informed_button.get_active()),
            'can_collect': int(collect_button.get_active()),
            'can_publish': int(publish_button.get_active()),
        }

#
# =============
# Curses dialog
# =============
#

def __show_curses_dialog():

    ''' Uses curses libraries to ask for privacy permissions '''

    # Gather user preferences
    error, result = '', ''
    try:
        screen = curses.initscr()
        while True:
            curses.echo()
            screen.addstr(TEXT_POLICY)
            result = screen.getstr()
            if result in ('ic', 'icp', 'q'):
                break
            screen.clear()
    except:
        error = str(asyncore.compact_traceback())

    # Always cleanup terminal
    curses.echo()
    curses.endwin()

    # Process results
    if error:
        raise RuntimeError('Curses failed: %s' % error)
    elif result == 'icp':
        return { 'informed': 1, 'can_collect': 1, 'can_publish': 1, }
    elif result == 'ic':
        return { 'informed': 1, 'can_collect': 1, 'can_publish': 0, }
    elif result == 'q':
        raise RuntimeError('User aborted installation')
    else:
        raise RuntimeError('Unexpected error')

#
# =============
# Main function
# =============
#

def __to_int(value):

    ''' Robust conversion from boolean to integer '''

    #
    # This is needed because some versions of Neubot before
    # 0.4.2 used to store booleans as strings instead of using
    # simple integers.
    #

    if value.lower() in ('true', 'on', 'yes'):
        return 1
    elif value.lower() in ('false', 'off', 'no'):
        return 0
    else:
        return int(value)

def __main():

    '''
     If needed show the privacy policy to the user and
     prompt for setting privacy permissions.
    '''

    try:
        options, arguments = getopt.getopt(sys.argv[1:], 'Cnf:')
    except getopt.error:
        sys.exit('Usage: preinst [-Cn] [-f database] [arguments]')

    #
    # We MUST allow arguments because the debian installer
    # passes as the first argument the action that it is
    # performing.
    #
    if arguments:
        syslog.syslog(syslog.LOG_INFO, 'Arguments: %s' % str(arguments))

    forcecurses = False
    database = '/var/neubot/database.sqlite3'
    for name, value in options:
        if name == '-C':
            forcecurses = True
        elif name == '-f':
            database = value
        elif name == '-n':
            database = ':memory:'

    # Initial privacy settings.
    settings = {
        'informed': 0,
        'can_collect': 0,
        'can_publish': 0,
    }

    #
    # Read settings from database
    # Note that here we MUST NOT fail because the database
    # might not even exist at this point.
    # Backward compatibility: the name of the setting was
    # can_share before the privacy policy was clarified in
    # neubot 0.4.3.
    #
    try:
        syslog.syslog(syslog.LOG_INFO, 'Database: %s' % database)
        connection = sqlite3.connect(database)
        cursor = connection.execute('SELECT * FROM config;')
        for name, value in cursor:
            if name == 'privacy.informed':
                settings['informed'] = __to_int(value)
            elif name == 'privacy.can_collect':
                settings['can_collect'] = __to_int(value)
            elif name == 'privacy.can_publish':
                settings['can_publish'] = __to_int(value)
            elif name == 'privacy.can_share':
                settings['can_publish'] = __to_int(value)
    except:
        error = str(asyncore.compact_traceback())
        syslog.syslog(syslog.LOG_INFO, 'Reading from database: %s' %
                                             error)
    else:
        syslog.syslog(syslog.LOG_INFO, 'Settings after database: %s' %
                                         str(settings))

    #
    # Succeed if permissions are OK.
    # We don't want to bother the user if she already
    # has given us permissions.
    #
    if settings['informed'] and settings['can_collect']:
        syslog.syslog(syslog.LOG_INFO, 'Settings are already OK')
        sys.exit(0)

    # Gather user preferences
    if USECURSES or forcecurses:
        settings = __show_curses_dialog()
    else:
        settings = __show_gtk_dialog()
    
    # Fail if settings are not OK
    if not(settings['informed'] and settings['can_collect']):
        syslog.syslog(syslog.LOG_ERR, 'Bad settings: %s' % str(settings))
        sys.exit(1)

    #
    # Write back settings.
    # We do the bare minimum, i.e. we create the table if it
    # does not exist and we insert or replace the values.
    # For robustness and backward compatibility the code always
    # creates the privacy.can_share variable.
    #
    connection = sqlite3.connect(database)
    connection.execute(''' CREATE TABLE IF NOT EXISTS config(
        name TEXT PRIMARY KEY, value TEXT); ''')
    connection.execute(''' INSERT OR REPLACE INTO config(name, value)
        VALUES('privacy.informed', ?); ''', (settings['informed'],))
    connection.execute(''' INSERT OR REPLACE INTO config(name, value)
        VALUES('privacy.can_collect', ?); ''', (settings['can_collect'],))
    connection.execute(''' INSERT OR REPLACE INTO config(name, value)
        VALUES('privacy.can_publish', ?); ''', (settings['can_publish'],))
    connection.execute(''' INSERT OR REPLACE INTO config(name, value)
        VALUES('privacy.can_share', ?); ''', (settings['can_publish'],))
    connection.commit()

    syslog.syslog(syslog.LOG_INFO, 'Written to database: %s' % str(settings))

def main():

    ''' Catch-all wrapper for the real main '''

    try:
        __main()
    except SystemExit:
        raise
    except:
        error = str(asyncore.compact_traceback())
        syslog.syslog(syslog.LOG_ERR, 'Unhandled exception: %s' % error)
        sys.exit(1)

if __name__ == '__main__':
    main()
