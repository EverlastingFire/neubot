#!/usr/bin/env python2.6

# bin/unix/neubot
# Copyright (c) 2010 NEXA Center for Internet & Society

# This file is part of Neubot.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.

import ConfigParser
import StringIO
import getopt
import logging
import logging.handlers
import os
import os.path
import pwd
import signal
import sys

STDERR_FORMAT = "[%(asctime)s] <%(levelname)s> %(message)s"
SYSLOG_FORMAT = "neubot[%(process)d]: <%(levelname)s> %(message)s"
USAGE = "Usage: neubot [-bEqVv] [-I path] [-O option] [--] [command [opts]]\n"
VERSION = "0.0.6"

def interrupt(signo, frame):
    logging.info("Got interrupt signal")
    os._exit(1)

def bootstrap():
    signal.signal(signal.SIGINT, interrupt)
    background = False
    incdir = "/usr/local/share"
    if not incdir in sys.path:
        sys.path.insert(0, incdir)
    noconf = False
    pidfile = "/var/run/neubot.pid"
    rcdir = "/etc/neubot"
    verbosity = logging.INFO
    try:
        options, arguments = getopt.getopt(sys.argv[1:], "bEI:O:qVv")
    except getopt.error:
        sys.stderr.write(USAGE)
        sys.stderr.write("Try `neubot help' for more help.\n")
        sys.exit(1)
    filelike = StringIO.StringIO()
    filelike.write("[DEFAULT]\r\n")
    for opt, arg in options:
        if opt == "-b":
            background = True
        elif opt == "-E":
            noconf = True
        elif opt == "-I":
            sys.path.insert(0, os.path.abspath(arg))
        elif opt == "-O":
            filelike.write(arg + "\r\n")
        elif opt == "-q":
            verbosity += 10                                             # XXX
            if verbosity > logging.ERROR:
                verbosity = logging.ERROR
        elif opt == "-V":
            print "Neubot", VERSION
            sys.exit(0)
        elif opt == "-v":
            verbosity -= 10                                             # XXX
            if verbosity < logging.DEBUG:
                verbosity = logging.DEBUG
    logger = logging.getLogger()
    handler = logging.StreamHandler()
    formatter = logging.Formatter(STDERR_FORMAT)
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(verbosity)
    configparser = ConfigParser.RawConfigParser()
    if not noconf:
        rclist = [ rcdir + "/config" ]
        if os.environ.has_key("HOME"):
            rclist.append(os.environ["HOME"] + "/.neubot/config")
        for rc in rclist:
            if os.path.isfile(rc):
                logging.info("Reading config file '%s'" % rc)
                configparser.read(rc)
    filelike.seek(0)
    configparser.readfp(filelike, "(commandline)")
    filelike = None
    logging.info("Trying to import neubot core")
    try:
        import neubot
    except ImportError:
        logging.error("Could not import neubot core")
        logging.error("Use -I to specify the path to neubot core")
        sys.exit(1)
    if len(arguments) == 0:
        arguments = ["auto"]
    if background:
        logging.info("Redirecting logs from stderr to syslog")
        handler = logging.handlers.SysLogHandler("/dev/log")
        formatter = logging.Formatter(SYSLOG_FORMAT)
        handler.setFormatter(formatter)
        logger.addHandler(handler)        # XXX
        logging.info("Changing current directory to '/'")
        os.chdir("/")
        logging.info("Setting the default umask")
        os.umask(022)
        logging.info("Redirecting stdio to '/dev/null'")
        logging.info("That's the last message you will see on console")
        for fd in range(0, 3):
            os.close(fd)
        stdin = os.open("/dev/null", os.O_RDWR)
        for fd in range(1, 3):
            os.dup2(stdin, fd)
        logging.info("Detaching from the controlling terminal")
        if os.fork() > 0:
            os._exit(0)
        logging.info("Becoming a session leader")
        os.setsid()
        logging.info("Detaching from the controlling session")
        if os.fork() > 0:
            os._exit(0)
        logging.info("Now running in background as a daemon")
        logging.info("Ignoring the INT signal")
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        logging.info("Trying to write the pidfile '%s'" % pidfile)
        try:
            f = open(pidfile, "wb")
            f.write(str(os.getpid()) + "\n")
            f.close()
        except IOError:
            pass
        if os.getuid() == 0:
            logging.info("Trying to drop root privileges")
            try:
                pw = pwd.getpwnam("_neubot")
            except KeyError:
                logging.error("Could not get '_neubot'"    \
                    "user information from password file")
                sys.exit(1)
            os.setgid(pw.pw_gid)
            os.setuid(pw.pw_uid)
            logging.info("Now running as the '_neubot' user")
    neubot.main.main(arguments)

if __name__ == "__main__":
    bootstrap()
