.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NEUBOT.NET 3"
.TH NEUBOT.NET 3 "2010-08-18" "Neubot 0.2.5" "Neubot manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
neubot.net \- Neubot's asynchronous I/O module
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
\&\fBimport neubot\fR
.PP
\&\fBneubot.net.connect\fR(address, port, connected, connecting=None,
    cantconnect=None, poller=neubot.net.pollers.poller,
    family=socket.AF_INET, secure=False, conntimeo=10)
.PP
\&\fBneubot.net.listen\fR(address, port, accepted, listening=None,
    cantbind=None, poller=neubot.net.pollers.poller,
    family=socket.AF_INET, secure=False, certfile=None,
    maxclients=7, maxconns=4)
.PP
stream.\fIrecv\fR(maxlen, recv_success, recv_error=None)
.PP
stream.\fIsend\fR(octets, send_success, send_error=None)
.PP
stream.\fIclose\fR()
.PP
stream.\fItimeout\fR = timeout
.PP
stream.\fInotify_closing\fR = closing
.PP
eof = stream.\fIeof\fR
.PP
stream.\fIcontext\fR = context
.PP
\&\fBneubot.net.loop\fR()
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This manual page presents Neubot's asynchronous I/O module.  The general
idea is that you start an I/O operation and register a callback to be
invoked when such operation completes successfully, and, optionally,
a callback to be invoked in case of failure, and, possibly, many more
callbacks.  The I/O module machinery will then perform the operation
on your behalf, and, depending on the result, will invoke the proper
callback.
.PP
The function \fBneubot.net.connect\fR() starts an asynchronous \fIconnect\fR\|(2)
to the specified \fIaddress\fR and \fIport\fR.  In case of success the function
\&\fIconnected\fR is invoked, while \fIcantconnect\fR, if specified, is invoked
in case of failure.  The optional function \fIconnecting\fR is invoked when
we are waiting for the connection to complete, and might be useful to
print a message such as \*(L"Connection in progress...\*(R".  If <secure> is True,
and the connection completes successfully, the I/O module will also wrap
the connected socket with an \fIssl\fR\|(3) object.  The \fIconntimeo\fR parameter
specifies the maximum amount of seconds we can wait for the connection
to complete.  The \fIpoller\fR parameter serves to specify an alternate
\&\fBPoller\fR object (which is the core class of the I/O module and dispatches
I/O events)\-\-usually you don't need to do that.  The \fIfamily\fR parameter
allows one to override the default protocol family, that is IPv4.
.PP
The function \fBneubot.net.listen\fR() creates a stream socket listening to
the specified \fIaddress\fR and \fIport\fR and waits for incoming connections.
If it is not possible to listen to the specified address and port,
the I/O module invokes the function \fIcantbind\fR, otherwise it invokes
the function \fIlistening\fR, which might be useful to print a message
such as \*(L"Listening on port 80.\*(R"  When there is an incoming connection,
the function \fIaccepted\fR is invoked.  The \fIcertfile\fR parameter might
be used to specify the path of the certificate file.  The I/O module
does not accept connections from more than \fImaxclients\fR clients and
allows each client to open up to \fImaxconns\fR connections.  All the
other parameters have the same meaning of the corresponding ones of
\&\fBneubot.net.connect\fR().
.PP
The \fIconnected\fR and \fIaccepted\fR callbacks receive a parameter that is
conventionally named \fIstream\fR and is an instance of the \fBStream\fR class.
This class wraps either a socket or an \s-1SSL\s0 object and implements three
asynchronous I/O operations: \fIrecv()\fR, \fIsend()\fR, and \fIclose()\fR.
.PP
The \fIrecv()\fR method starts an asynchronous recv operation.  The operation
will read up to \fImaxlen\fR bytes and the I/O module machinery will
invoke \fIrecv_success\fR on success, and \fIrecv_error\fR on failure.
The first function receives two parameters: a reference to the stream
and a reference to a string that contains the read bytes.  The second one
receives a reference to the stream as its only parameter.
.PP
The \fIsend()\fR method starts an asynchronous send operation.  The operation
will send the \fIoctets\fR string over the network and the I/O module
machinery will invoke \fIsend_success\fR on success, and \fIsend_error\fR
on failure.  The first function receives two parameters: a reference
to the stream and a reference to the sent string.  The second one
receives a reference to the stream as its only parameter.
.PP
The \fIclose()\fR method close the underlying socket or \s-1SSL\s0 connection and
frees all the resources.  It is important that you drop any reference
to the stream object after the close, for the object to be correctly
garbage collected.  An alternative to an explicit close is to drop
the references to the stream either in the \fIrecv_success()\fR or in the
\&\fIsend_success()\fR callback (this works because the I/O module does not keep
any reference to the stream when these callbacks are running.)
.PP
Apart from these three methods, there are some worth mentioning members
of the \fBStream\fR class: \fItimeout\fR, \fInotify_closing\fR, \fIeof\fR, and
\&\fIcontext\fR.
.PP
The \fItimeout\fR member specifies the timeout (in seconds) for recv and
send I/O operations.
.PP
If the \fInotify_closing\fR callback is not None, it will be invoked when
the stream is closing.  This is an alternate mechanism to get notified
that a pending I/O operation failed, and could be employed instead of
\&\fIrecv_error\fR and \fIsend_error\fR.
.PP
The \fIeof\fR member is True when the remote host closed the connection.
It allows to discriminate between a legitimate close from the remote
host and another network error.  This might be useful if the protocol
specifies that certain messages are \s-1EOF\s0 terminated (as happens, for
example, with \s-1HTTP/1\s0.0).
.PP
The \fIcontext\fR member is the proper place where to store a reference
to the context attached to a network connection (such as the state of
the \s-1HTTP\s0 protocol.)  Indeed, if this member is the only reference to
the context, the stream distruction will also trigger the distruction
of the context object (removing the need of an explicit notification.)
.PP
The function \fBneubot.net.loop\fR() keeps running the module machinery
and dispatches I/O events to the interested streams.  If you forget to
invoke this function your program will not perform any network I/O.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
In this example we retrieve the raw response of a remote webserver.
We don't do any error checking for simplicity:
.PP
.Vb 2
\&    import neubot
\&    import sys
\&
\&    class Getraw:
\&        def _\|_init_\|_(self, host):
\&            self.request  = "GET / HTTP/1.1\er\en"
\&            self.request += "Host: " + host + "\er\en"
\&            self.request += "Connection: close\er\en"
\&            self.request += "\er\en"
\&            neubot.net.connect(host, "80", self.connected)
\&
\&        def connected(self, stream):
\&            stream.send(self.request, self.sent)
\&
\&        def sent(self, stream, octets):
\&            stream.recv(8000, self.received)
\&
\&        def received(self, stream, octets):
\&            sys.stdout.write(octets)
\&            stream.recv(8000, self.received)
\&
\&    if _\|_name_\|_ == "_\|_main_\|_":
\&        Getraw(sys.argv[1])
\&        neubot.net.loop()
.Ve
.PP
In _\|_init_\|_() we prepare the request, we start an asynchronous connect,
and we register self.connected to be invoked once the connection is
complete.
.PP
When the connection completes, self.\fIconnected()\fR starts an asynchronous
send, and registers self.sent to be invoked once the request has been
sent.
.PP
When the request has been sent, self.\fIsent()\fR starts an asynchronous recv,
and registers self.received to be invoked once some bytes are received.
.PP
The function self.\fIreceived()\fR prints on the standard output the chunk
received and then starts another asynchronous receive operation.
This repeats until the server closes the connection.
.PP
In the main we construct the Getraw object and we invoke the main loop
of the I/O module, neubot.net.\fIloop()\fR.
.PP
Assuming the example above is contained in the file getraw.py and assuming
that Neubot is installed in /usr/local/share, to run getraw.py type:
.PP
.Vb 2
\&    $ export PYTHONPATH=/usr/local/share:$PYTHONPATH
\&    $ python getraw.py http://www.example.com/
.Ve
.PP
We need to augment \s-1PYTHONPATH\s0 because Neubot is not installed together
with the system's Python distribution.
.PP
It is possible to improve the above example with some error checking,
as follows:
.PP
.Vb 1
\&        ...
\&
\&        def _\|_init_\|_(self, host):
\&            ...
\&            neubot.net.connect(host, "80", self.connected,
\&                             cantconnect=self.cantconnect,
\&                               connecting=self.connecting)
\&
\&        def self.connecting(self):
\&            sys.stderr.write("Connection in progress...\en")
\&
\&        def self.cantconnect(self):
\&            sys.stderr.write("Connection failed\en")
\&
\&        ...
\&
\&        def connected(self, stream):
\&            sys.stderr.write("Sending in progress...\en")
\&            stream.send(self.request, self.sent,
\&             send_error=self.cantsend)
\&
\&        def cantsend(self, stream):
\&            sys.stderr.write("Send failed\en")
\&
\&        def sent(self, stream, octets):
\&            sys.stderr.write("Receiving in progress...\en")
\&            stream.recv(8000, self.received,
\&             recv_error=self.cantrecv)
\&
\&        def received(self, stream, octets):
\&            sys.stdout.write(octets)
\&            stream.recv(8000, self.received,
\&             recv_error=self.cantrecv)
\&
\&        def cantrecv(self, stream):
\&            if not stream.eof:
\&                sys.stderr.write("Recv failed\en")
\&            else:
\&                sys.stderr.write("Done\en")
\&
\&        ...
.Ve
.SH "FILES"
.IX Header "FILES"
Neubot sources are installed in \f(CW$SHARE\fR, where \f(CW$SHARE\fR is \fI/usr/local/share\fR
when installing from sources, and is \fI/usr/share\fR when installing with a
package manager.  In this section we will use \f(CW$SHARE\fR for generality.
.ie n .IP "$SHARE/neubot/net/_\|_init_\|_.py" 4
.el .IP "\f(CW$SHARE\fR/neubot/net/_\|_init_\|_.py" 4
.IX Item "$SHARE/neubot/net/__init__.py"
Exports the interface described in this manual page.
.ie n .IP "$SHARE/neubot/net/connectors.py" 4
.el .IP "\f(CW$SHARE\fR/neubot/net/connectors.py" 4
.IX Item "$SHARE/neubot/net/connectors.py"
Implementation of \fBneubot.net.\f(BIconnect()\fB\fR.
.ie n .IP "$SHARE/neubot/net/listeners.py" 4
.el .IP "\f(CW$SHARE\fR/neubot/net/listeners.py" 4
.IX Item "$SHARE/neubot/net/listeners.py"
Implementation of \fBneubot.net.\f(BIlisten()\fB\fR.
.ie n .IP "$SHARE/neubot/net/pollers.py" 4
.el .IP "\f(CW$SHARE\fR/neubot/net/pollers.py" 4
.IX Item "$SHARE/neubot/net/pollers.py"
Implementation of the \fBPoller\fR class.
.ie n .IP "$SHARE/neubot/net/streams.py" 4
.el .IP "\f(CW$SHARE\fR/neubot/net/streams.py" 4
.IX Item "$SHARE/neubot/net/streams.py"
Implementation of the \fBStream\fR class.
.SH "AUTHOR"
.IX Header "AUTHOR"
Simone Basso <bassosimone@gmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\& Copyright (c) 2010 NEXA Center for Internet & Society.
\&
\& Neubot is free software: you can redistribute it and/or
\& modify it under the terms of the GNU General Public License
\& as published by the Free Software Foundation, either version
\& 3 of the License, or (at your option) any later version.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "The Neubot Project <http://nexa.polito.it/neubot>" 2
.IX Item "The Neubot Project <http://nexa.polito.it/neubot>"
.PD 0
.IP "The Neubot Archives <http://www.neubot.org:8080/>" 2
.IX Item "The Neubot Archives <http://www.neubot.org:8080/>"
.IP "\fIneubot\fR\|(1)" 2
.IX Item "neubot"
